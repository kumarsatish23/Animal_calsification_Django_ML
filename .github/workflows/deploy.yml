name: Deploy to EC2

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

env:
  DOCKER_IMAGE_NAME: animal-classifier
  REGISTRY: docker.io

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run Django tests
      run: |
        python manage.py test
      env:
        DJANGO_SETTINGS_MODULE: dog_cat_classifier.settings

  build:
    needs: test
    runs-on: ubuntu-latest
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: [test, build]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to EC2
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_PRIVATE_KEY }}
        port: ${{ secrets.EC2_PORT || 22 }}
        script: |
          set -e  # Exit on any error
          
          echo "ðŸš€ Starting deployment process..."
          
          # Update system packages
          echo "ðŸ“¦ Updating system packages..."
          sudo apt-get update || { echo "âŒ Failed to update packages"; exit 1; }

          # Install Docker if not present
          if ! command -v docker &> /dev/null; then
            echo "ðŸ³ Installing Docker..."
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            sudo usermod -aG docker $USER
            sudo systemctl start docker
            sudo systemctl enable docker
            echo "âœ… Docker installed successfully"
          else
            echo "âœ… Docker already installed"
          fi

          # Install Docker Compose if not present
          if ! command -v docker-compose &> /dev/null; then
            echo "ðŸ”§ Installing Docker Compose..."
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            echo "âœ… Docker Compose installed successfully"
          else
            echo "âœ… Docker Compose already installed"
          fi

          # Create application directory
          echo "ðŸ“ Setting up application directory..."
          sudo mkdir -p /opt/animal-classifier
          cd /opt/animal-classifier

          # Create environment file
          echo "âš™ï¸ Setting up environment..."
          sudo tee .env.production > /dev/null << EOF
          DEBUG=0
          SECRET_KEY=$(openssl rand -base64 32)
          ALLOWED_HOSTS=*
          DJANGO_SETTINGS_MODULE=dog_cat_classifier.settings
          DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
          EOF

          # Create production compose file
          echo "ðŸ“ Creating production compose file..."
          sudo tee docker-compose.prod.yml > /dev/null << 'EOF'
          version: '3.8'
          services:
            web:
              image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:latest
              ports:
                - "80:8000"
              volumes:
                - ./media:/app/media
                - ./staticfiles:/app/staticfiles
                - ./logs:/app/logs
              environment:
                - DEBUG=0
                - DJANGO_SETTINGS_MODULE=dog_cat_classifier.settings
                - ALLOWED_HOSTS=*
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "python", "-c", "import requests; requests.get('http://localhost:8000', timeout=10)"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          EOF

          # Create necessary directories
          sudo mkdir -p media staticfiles logs
          
          # Login to Docker Hub
          echo "ðŸ” Logging into Docker Hub..."
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | sudo docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin || { echo "âŒ Docker login failed"; exit 1; }

          # Stop existing containers
          echo "ðŸ›‘ Stopping existing containers..."
          sudo docker-compose -f docker-compose.prod.yml down || true

          # Pull latest image
          echo "ðŸ“¥ Pulling latest Docker image..."
          sudo docker pull ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:latest || { echo "âŒ Failed to pull Docker image"; exit 1; }

          # Start new containers
          echo "ðŸš€ Starting new containers..."
          sudo docker-compose -f docker-compose.prod.yml up -d || { echo "âŒ Failed to start containers"; exit 1; }

          # Wait for container to be ready
          echo "â³ Waiting for containers to be ready..."
          sleep 30

          # Check if container is running
          if ! sudo docker-compose -f docker-compose.prod.yml ps | grep -q "Up"; then
            echo "âŒ Container failed to start properly"
            sudo docker-compose -f docker-compose.prod.yml logs
            exit 1
          fi

          # Run migrations
          echo "ðŸ”§ Running database migrations..."
          sudo docker-compose -f docker-compose.prod.yml exec -T web python manage.py migrate || { echo "âŒ Migration failed"; exit 1; }

          # Collect static files
          echo "ðŸ“š Collecting static files..."
          sudo docker-compose -f docker-compose.prod.yml exec -T web python manage.py collectstatic --noinput || { echo "âŒ Static files collection failed"; exit 1; }

          # Clean up unused images
          echo "ðŸ§¹ Cleaning up unused Docker images..."
          sudo docker image prune -af

          # Final status check
          echo "ðŸ“Š Final container status:"
          sudo docker-compose -f docker-compose.prod.yml ps
          
          echo "âœ… Deployment completed successfully!"
          echo "ðŸŒ Application should be accessible at http://$(curl -s http://checkip.amazonaws.com/)"

  notify:
    needs: [deploy]
    runs-on: ubuntu-latest
    if: always() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
    - name: Notify deployment success
      if: needs.deploy.result == 'success'
      run: |
        echo "âœ… Deployment to EC2 successful!"
        echo "ðŸŒ Application is now running on your EC2 instance"
        
    - name: Notify deployment failure
      if: needs.deploy.result != 'success'
      run: |
        echo "âŒ Deployment to EC2 failed!"
        echo "ðŸ” Check the deployment logs for details"
        echo "ðŸ“‹ Deploy job status: ${{ needs.deploy.result }}"
        exit 1
